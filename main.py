import pygame
import random
import math

# Initialize pygame
pygame.init()

SCREEN_SIZE = (1300, 800)

class Game_Object(pygame.sprite.Sprite):
    """Generic game object. 
    Implements sprites rotation and movement.
    _image and _size must be defined in child class."""

    def __init__(self, position):
        super().__init__()
        self._speed    = [0, 0] # [x, y]
        self._angle    = 0
        self._spin     = 0
        self.rect      = self._image.get_rect()
        self.rect.x    = position[0]
        self.rect.y    = position[1]

    def update(self):
        self.rect.x += self._speed[0] / interface.fps
        self.rect.y += self._speed[1] / interface.fps

        w, h       = self._image.get_size()
        box        = [pygame.math.Vector2(p) for p in [(0, 0), (w, 0), (w, -h), (0, -h)]]
        box_rotate = [p.rotate(self._angle) for p in box]
        min_box    = (min(box_rotate, key=lambda p: p[0])[0], min(box_rotate, key=lambda p: p[1])[1])
        max_box    = (max(box_rotate, key=lambda p: p[0])[0], max(box_rotate, key=lambda p: p[1])[1])

        # calculate the translation of the pivot 
        pivot        = pygame.math.Vector2(self._size[0] /2 , - self._size[1] /2)
        pivot_rotate = pivot.rotate(self._angle)
        pivot_move   = pivot_rotate - pivot

        # calculate the upper left origin of the rotated image
        origin = (self.rect.x - self._size[0] / 2 + min_box[0] - pivot_move[0], self.rect.y - self._size[1] / 2 - max_box[1] + pivot_move[1])

        self.rotated_image = pygame.transform.rotate(self._image, self._angle)
        interface.screen.blit(self.rotated_image, origin)


class Ship(Game_Object):
    """Ship game object with fixed maximum velocity and variable acceleration.
    
    Arguments:
        start_pos {float: array} -- [x, y]
        image {str} -- Ship Image directory
        bullet_speed {float} -- Ship bullet speed
    """
    def __init__(self, start_pos, image, bullet_speed):
        self._image_dir    = image
        self._image        = pygame.image.load(image).convert_alpha()
        super().__init__(start_pos)
        self._acceleration = 0.7
        self._spin         = 4.0
        self._max_speed    = 10.0
        self._speed_limit  = self._max_speed
        self._size         = self._image.get_size()
        self._stabilizer   = 0.2
        self._bullet_speed = bullet_speed
    
    def __str__(self):
        return("""Ship class:
        _acceleration: %f
        _max_speed: %f
        _spin: %f
        _stabilizer: %f
        _bullet_speed: %f
        _image: %s""" %(self._acceleration, self._max_speed, self._spin,
                       self._stabilizer, self._bullet_speed, self._image_dir))
    
    def update(self, pressedKeys):
        """Overriden pygame.sprite.sprite method.
        Acceleration is splitted according to its vectorial component and in-game events.
        
        Arguments:
            pressedKeys {Tuple} -- collection of events generated by pygame.key
        """

        self._speed_limit = [abs(self._max_speed * math.cos(math.radians(self._angle))), 
                             abs(self._max_speed * math.sin(math.radians(self._angle)))]
        
        if pressedKeys[pygame.K_UP]:
            if self._speed[0] <= self._speed_limit[0] and self._speed[0] >= -self._speed_limit[0]:
                self._speed[0] += self._acceleration * math.cos(math.radians(self._angle)) / interface.fps
            elif self._speed[0] > self._speed_limit[0]:
                self._speed[0] = self._speed[0] - self._stabilizer / interface.fps
            elif self._speed[0] < -self._speed_limit[0]:
                self._speed[0] = self._speed[0] + self._stabilizer / interface.fps

            if self._speed[1] <= self._speed_limit[1] and self._speed[1] >= -self._speed_limit[1]:
                self._speed[1] -= self._acceleration * math.sin(math.radians(self._angle)) / interface.fps
            elif self._speed[1] > self._speed_limit[1]:
                self._speed[1] = self._speed[1] - self._stabilizer / interface.fps
            elif self._speed[1] < -self._speed_limit[1]:
                self._speed[1] = self._speed[1] + self._stabilizer / interface.fps
        
        elif pressedKeys[pygame.K_DOWN]:
            if self._speed[0] <= self._speed_limit[0] and self._speed[0] >= -self._speed_limit[0]:
                self._speed[0] -= self._acceleration / 2 * math.cos(math.radians(self._angle)) / interface.fps
            elif self._speed[0] > self._speed_limit[0]:
                self._speed[0] = self._speed[0] - self._stabilizer / interface.fps
            elif self._speed[0] < -self._speed_limit[0]:
                self._speed[0] = self._speed[0] + self._stabilizer / interface.fps

            if self._speed[1] <= self._speed_limit[1] and self._speed[1] >= -self._speed_limit[1]:
                self._speed[1] += self._acceleration / 2 * math.sin(math.radians(self._angle)) / interface.fps
            elif self._speed[1] > self._speed_limit[1]:
                self._speed[1] = self._speed[1] - self._stabilizer / interface.fps
            elif self._speed[1] < -self._speed_limit[1]:
                self._speed[1] = self._speed[1] + self._stabilizer / interface.fps

        if pressedKeys[pygame.K_LEFT]:
            self._angle += self._spin / interface.fps

        if pressedKeys[pygame.K_RIGHT]:
            self._angle -= self._spin / interface.fps

        if pressedKeys[pygame.K_SPACE]:
            new_bullet = Bullet([self.rect.x, self.rect.y], self._angle, self._bullet_speed)
            interface.bullets.add(new_bullet)
            interface.all.add(new_bullet)

        Game_Object.update(self)


class Bullet(Game_Object):
    """Bullet game object shot by ships according to their angle.
        
        Arguments:
            start_pos {array: float} -- [x, y] start position
            angle {float} -- angle of the vector in degrees
            bullet_speed {float} -- bullet speed
        """

    def __init__(self, start_pos, angle, bullet_speed):
        self._image = pygame.image.load('Images/bullet.png').convert_alpha()
        super().__init__(start_pos)
        self._angle = angle
        self._spin  = 0
        self._bullet_speed = bullet_speed
        self._size  = self._image.get_size( )

    def update(self):
        self._speed = [self._bullet_speed * math.cos(math.radians(self._angle)) / interface.fps, 
                       self._bullet_speed * - math.sin(math.radians(self._angle)) / interface.fps]
        Game_Object.update(self)


class Solid(Game_Object):
    """Simple game surface
    
        Arguments:
            position {array: float} -- [x, y] start position
            dimension {array: float} -- [x, y] polygon dimension
            color {tuple} -- (R, G, B) color standard"""

    def __init__(self, position, dimension, color):
        self._image = pygame.Surface(dimension)
        super().__init__(position)
        self._image.fill(color)
        self._size = self._image.get_size()
    
    def update(self):
        Game_Object.update(self)
        self.value = pygame.sprite.groupcollide(interface.all, interface.environment, True, False)
            
        
class UI:

    def __init__(self):
        # Setting up the screen
        self.screen = pygame.display.set_mode(SCREEN_SIZE)

        # Game clock setting
        self.clock = pygame.time.Clock()

        # Group of Ships
        self.ships   = pygame.sprite.Group()
        self.bullets = pygame.sprite.Group()
        self.environment = pygame.sprite.Group()
        self.all = pygame.sprite.Group()

        # User
        self.user = Ship([100, 200], 'Images/ship.png', 10)
        self.ships.add(self.user)
        self.all.add(self.user)

        # Finalize screen
        pygame.display.set_caption("Shooter")

        dimension = [[[2200, 15], [1, 100]], [[2200, 5], [1, 799]], [[5, 2000], [1, 1]], [[5, 2000], [1099, 1]]]
        for obj in dimension:
            item = Solid(obj[1], obj[0], (255, 0, 0))
            self.environment.add(item)

    def main(self):
        done = False

        # check for exit
        while not done:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    done = True

            self.fps = 30.0 / self.clock.tick(60)

            # Refresh screen and update sprites
            self.screen.fill((0, 0, 0))
            self.bullets.update()
            self.ships.update(pygame.key.get_pressed())
            self.environment.update()
            pygame.display.update()
            #print(self.user._speed , self.user._angle, self.clock.get_fps(), self.bullets.sprites())

        pygame.quit()


if __name__ == "__main__":
    interface = UI()
    interface.main()
