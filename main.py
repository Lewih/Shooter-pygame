import pygame
import random
import math
import threading
import socket

# Initialize pygame
pygame.init()

SCREEN_SIZE = (1100, 800)

class Server(threading.Thread):
	PORT = 50000

	def __init__(self):
		super().__init__()
		self.text = ''
		self.client = None
		self.address = None

		self.server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
		self.server.bind(('localhost', self.PORT))
		self.server.listen(1)

	def send(self, message):
		try:
			self.server.sendall(bytes(str(message), 'ascii'))
		except Exception as err:
			print(err)
			exit(1)

	def reading(self):
		if self.text=='exit':
			self.send('shutdown()')
			self.server.shutdown(socket.SHUT_RDWR)
			self.server.close()

		else:
			self.send(interface.user.str)

	def run(self):
		print('\nwaiting for new connection...')
		self.client, self.address = self.server.accept()
		print('\nConnected to ',self.address + '\n')
		self.client.send(bytes("Connected!\n", 'ascii'))
		while True:
			try:
				self.text = str(self.client.recv(4096), 'ascii')
				self.reading()
			except Exception as err:
				self.send(err)

class Client(threading.Thread):
    pass


class Game_Object(pygame.sprite.Sprite):
    """Generic game object. 
    Implements sprites rotation and movement.
    _image and _size must be defined in child class.
    """

    def __init__(self, position):
        super().__init__()
        self._speed    = [0, 0] # [x, y]
        self._angle    = 0
        self._spin     = 0
        self.rect      = self._image.get_rect()
        self.rect.x    = position[0]
        self.rect.y    = position[1]

    def update(self):
        self.rect.x += self._speed[0] / interface.fps
        self.rect.y += self._speed[1] / interface.fps

        w, h       = self._image.get_size()
        box        = [pygame.math.Vector2(p) for p in [(0, 0), (w, 0), (w, -h), (0, -h)]]
        box_rotate = [p.rotate(self._angle) for p in box]
        min_box    = (min(box_rotate, key=lambda p: p[0])[0], min(box_rotate, key=lambda p: p[1])[1])
        max_box    = (max(box_rotate, key=lambda p: p[0])[0], max(box_rotate, key=lambda p: p[1])[1])

        # calculate the translation of the pivot 
        pivot        = pygame.math.Vector2(self._size[0] /2 , - self._size[1] /2)
        pivot_rotate = pivot.rotate(self._angle)
        pivot_move   = pivot_rotate - pivot

        # calculate the upper left origin of the rotated image
        origin = (self.rect.x - self._size[0] / 2 + min_box[0] - pivot_move[0], self.rect.y - self._size[1] / 2 - max_box[1] + pivot_move[1])

        self.rotated_image = pygame.transform.rotate(self._image, self._angle)
        interface.screen.blit(self.rotated_image, origin)


class Ship(Game_Object):
    """Ship game object.
    
    Arguments:
        start_pos {float: array} -- [x, y]
        image {str} -- Ship Image directory
        acceleration {float} -- Ship acceleration
        spin {float} -- Ship spin
        max_v_speed {float} -- nominal max vertical speed
        max_h_speed {float} -- nominal max horizontal speed
        bullet_speed {float} -- Ship bullet speed
        fire_rate {float} -- fire interval
    """
    
    def __init__(self, start_pos, image, acceleration,
                 spin, max_v_speed, max_h_speed, bullet_speed, fire_rate):
        self._image_dir    = image
        self._image        = pygame.image.load(image).convert_alpha()
        super().__init__(start_pos)
        self._size         = self._image.get_size()
        self._acceleration = acceleration
        self._spin         = spin
        self._max_v_speed  = max_v_speed
        self._max_h_speed  = max_h_speed
        self._bullet_speed = bullet_speed
        self._fire_rate    = fire_rate
        self._bullet_timer = 0
    
    def __str__(self):
        return("""Ship = {
        _position: [%f, %f],
        _speed: [%f, %f],
        _acceleration: %f,
        _max_v_speed: %f,
        _spin: %f,
        _max_h_speed: %f,
        _bullet_speed: %f
        _fire_rate_ %f,
        _image: %s}""" %(self.rect.x, self.rect.y, self._speed[0], self._speed[1],
                         self._acceleration, self._max_v_speed, self._spin,
                         self._max_h_speed, self._bullet_speed, self._fire_rate, self._image_dir))
    
    def update(self, pressedKeys):
        """Overriden pygame.sprite.sprite method.
        Acceleration is applied according to its vectorial component and in-game events.
        
        Arguments:
            pressedKeys {Tuple} -- collection of events generated by pygame.key
        """

        if self._bullet_timer > 0:
            self._bullet_timer -= 1 / interface.fps

        cos = math.cos(math.radians(self._angle))
        sin = math.sin(math.radians(self._angle))
        cos90 = math.cos(math.radians(self._angle + 90))
        sin90 = math.sin(math.radians(self._angle + 90))

        self._rel_max_v_speed = [self._max_v_speed * cos, 
                                 self._max_v_speed * -sin]
        
        self._rel_max_h_speed = [self._max_v_speed * cos90, 
                                 self._max_v_speed * -sin90]
        
        if pressedKeys[pygame.K_UP]:
            if self._rel_max_v_speed[0] > 0:
                if self._speed[0] <= self._rel_max_v_speed[0]:
                    self._speed[0] += self._acceleration * cos / interface.fps
            else:
                if self._speed[0] >= self._rel_max_v_speed[0]:
                    self._speed[0] += self._acceleration * cos / interface.fps

            if self._rel_max_v_speed[1] > 0:
                if self._speed[1] <= self._rel_max_v_speed[1]:
                    self._speed[1] += self._acceleration * -sin / interface.fps
            else:
                if self._speed[1] >= self._rel_max_v_speed[1]:
                    self._speed[1] += self._acceleration * -sin / interface.fps
            
        elif pressedKeys[pygame.K_DOWN]:
            if self._rel_max_v_speed[0] > 0:
                if self._speed[0] >= -self._rel_max_v_speed[0]:
                    self._speed[0] -= self._acceleration * cos / interface.fps
            else:
                if self._speed[0] <= -self._rel_max_v_speed[0]:
                    self._speed[0] -= self._acceleration * cos / interface.fps

            if self._rel_max_v_speed[1] > 0:
                if self._speed[1] >= -self._rel_max_v_speed[1]:
                    self._speed[1] -= self._acceleration * -sin / interface.fps
            else:
                if self._speed[1] <= -self._rel_max_v_speed[1]:
                    self._speed[1] -= self._acceleration * -sin / interface.fps
        
        if pressedKeys[pygame.K_q]:
            if self._rel_max_h_speed[0] > 0:
                if self._speed[0] <= self._rel_max_h_speed[0]:
                    self._speed[0] += self._max_h_speed * cos90 / interface.fps
            else:
                if self._speed[0] >= self._rel_max_h_speed[0]:
                    self._speed[0] += self._max_h_speed * cos90 / interface.fps

            if self._rel_max_h_speed[1] > 0:
                if self._speed[1] <= self._rel_max_h_speed[1]:
                    self._speed[1] += self._max_h_speed * -sin90 / interface.fps
            else:
                if self._speed[1] >= self._rel_max_h_speed[1]:
                    self._speed[1] += self._max_h_speed * -sin90 / interface.fps
        
        elif pressedKeys[pygame.K_e]:
            if self._rel_max_h_speed[0] > 0:
                if self._speed[0] >= -self._rel_max_h_speed[0]:
                    self._speed[0] -= self._max_h_speed * cos90 / interface.fps
            else:
                if self._speed[0] <= -self._rel_max_h_speed[0]:
                    self._speed[0] -= self._max_h_speed * cos90 / interface.fps

            if self._rel_max_h_speed[1] > 0:
                if self._speed[1] >= -self._rel_max_h_speed[1]:
                    self._speed[1] -= self._max_h_speed * -sin90 / interface.fps
            else:
                if self._speed[1] <= -self._rel_max_h_speed[1]:
                    self._speed[1] -= self._max_h_speed * -sin90 / interface.fps

        if pressedKeys[pygame.K_LEFT]:
            self._angle += self._spin / interface.fps

        if pressedKeys[pygame.K_RIGHT]:
            self._angle -= self._spin / interface.fps
        
        if pressedKeys[pygame.K_w]:
            self._speed = [0, 0]

        if pressedKeys[pygame.K_SPACE] and self._bullet_timer <= 0:
            self._bullet_timer = self._fire_rate
            new_bullet = Bullet([self.rect.x, self.rect.y], self._angle, self._bullet_speed)
            interface.bullets.add(new_bullet)
            interface.all.add(new_bullet)

        Game_Object.update(self)


class Bullet(Game_Object):
    """Bullet game object shot by sprites according to their angle.
        
        Arguments:
            start_pos {array: float} -- [x, y] start position
            angle {float} -- angle of the vector in degrees
            bullet_speed {float} -- bullet speed
    """

    def __init__(self, start_pos, angle, bullet_speed):
        self._image = pygame.image.load('Images/bullet.png').convert_alpha()
        super().__init__(start_pos)
        self._angle = angle
        self._spin  = 0
        self._bullet_speed = bullet_speed
        self._size  = self._image.get_size( )
        self._speed = [self._bullet_speed * math.cos(math.radians(self._angle)), 
                       self._bullet_speed * -math.sin(math.radians(self._angle))]

    def update(self):
        Game_Object.update(self)


class Solid(Game_Object):
    """Simple game surface.
    
        Arguments:
            position {array: float} -- [x, y] start position
            dimension {array: float} -- [x, y] polygon dimension
            color {tuple} -- (R, G, B) color standard
    """

    def __init__(self, position, dimension, color):
        self._image = pygame.Surface(dimension)
        super().__init__(position)
        self._image.fill(color)
        self._size = self._image.get_size()
    
    def update(self):
        Game_Object.update(self)
        self.value = pygame.sprite.groupcollide(interface.all, interface.environment, True, False)


class UI:

    def __init__(self):
        # Setting up the screen
        self.screen = pygame.display.set_mode(SCREEN_SIZE)

        # Game clock setting
        self.clock = pygame.time.Clock()

        # Group of Ships
        self.ships   = pygame.sprite.Group()
        self.bullets = pygame.sprite.Group()
        self.environment = pygame.sprite.Group()
        self.all = pygame.sprite.Group()

        # User
        self.user = Ship([100, 200], 'Images/ship.png', 0.7, 10, 10.0, 0.4, 10.0, 10)
        self.ships.add(self.user)
        self.all.add(self.user)

        # Finalize screen
        pygame.display.set_caption("Shooter")

        dimension = [[[2200, 15], [1, 100]], [[2200, 5], [1, 799]], [[5, 2000], [1, 1]], [[5, 2000], [1099, 1]]]
        for obj in dimension:
            item = Solid(obj[1], obj[0], (255, 0, 0))
            self.environment.add(item)

    def main(self):
        done = False

        # check for exit
        while not done:
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    done = True

            self.fps = 30.0 / self.clock.tick(100)

            # Refresh screen and update sprites
            self.screen.fill((0, 0, 0))
            self.bullets.update()
            self.ships.update(pygame.key.get_pressed())
            self.environment.update()
            pygame.display.update()
            #print(self.user._speed , self.user._angle, self.user._rel_max_h_speed, self.user._rel_max_v_speed, self.clock.get_fps())

        pygame.quit()


if __name__ == "__main__":
    interface = UI()
    interface.main()
